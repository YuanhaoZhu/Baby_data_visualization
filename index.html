<html>
<head>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pangolin&display=swap');
    text{
      font-family: 'Pangolin', cursive;
      font-size: 15px
    }
  </style>
</head>
<body>
	<svg id="bubbleGraph" height="600" width="800" style="background: #sff; " ></svg>
  <svg id="lineGraph" height="600" width="800" style="background: #sff; " ></svg>

  <script>
  	const bubbleLayer = d3.select("#bubbleGraph").append("g");
  	const bubbleLegend = d3.select("#bubbleGraph").append("g");

    const bubbleWidth = d3.select("#bubbleGraph").attr("width");
    const bubbleHeight = d3.select("#bubbleGraph").attr("height");
    const bubblePadding = 50
    const bubblePaddedHeight = bubbleHeight - 2*bubblePadding
    const bubblePaddedWidth = bubbleWidth - 2*bubblePadding

    const requestData = async () => {
      const bbnames = await d3.csv("Popular_Baby_Names.csv", d3.autoType)
      console.log(bbnames)



      nameBubbleData = bbnames.filter((d)=>{return d["Rank"] <= 10 && d["Year of Birth"] === 2015;});

      console.log(nameBubbleData)

      const rankExtent = d3.extent(nameBubbleData, d => d['Rank']);
      const rankScale = d3.scaleLinear().domain(rankExtent).range([bubblePadding, bubblePaddedHeight]);

      const colorScale = d3.scaleOrdinal()
                           .domain(["WHITE NON HISPANIC","HISPANIC","BLACK NON HISPANIC","ASIAN AND PACIFIC ISLANDER"])
                           .range(["#FEF1E2","#E28E51","#934914","#FDDEBB"]);
      const genderColorScale = d3.scaleOrdinal()
                           .domain(["FEMALE","MALE"])
                           .range(["pink","#99ccff"]);

      console.log(nameBubbleData)







      // Construct a d3.forceSimulation model for your network diagram.
      var sim = d3.forceSimulation()
                  .nodes(nameBubbleData)
                  // .force("links", d3.forceLink()
                  //                         .links(edges)
                  //                         .id( d => d['icpsr'] ) )
                  // .force("repulse", d3.forceManyBody().strength(-150) )
                  .force("ypos", d3.forceY().y(d => rankScale(d.Rank)).strength( 0.8 ) )//y-positioning force, set less than 1.0
                  .force("xpos", d3.forceX().x( d=> {
                    if (d["Ethnicity"] === "WHITE NON HISPANIC"&&d.Gender ==="MALE"){return bubblePaddedWidth*0.22}
                    if (d["Ethnicity"] === "WHITE NON HISPANIC"&&d.Gender ==="FEMALE"){return bubblePaddedWidth*0.28}
                    if (d["Ethnicity"] === "HISPANIC"&&d.Gender ==="MALE"){return bubblePaddedWidth*0.47}
                    if (d["Ethnicity"] === "HISPANIC"&&d.Gender ==="FEMALE"){return bubblePaddedWidth*0.53}
                    if (d["Ethnicity"] === "BLACK NON HISPANIC"&&d.Gender ==="MALE"){return bubblePaddedWidth*0.72}
                    if (d["Ethnicity"] === "BLACK NON HISPANIC"&&d.Gender ==="FEMALE"){return bubblePaddedWidth*0.78}
                    if (d["Ethnicity"] === "ASIAN AND PACIFIC ISLANDER"&&d.Gender ==="MALE"){return bubblePaddedWidth*0.94}
                    if (d["Ethnicity"] === "ASIAN AND PACIFIC ISLANDER"&&d.Gender ==="FEMALE"){return bubblePaddedWidth} 
                    //if (d["Ethnicity"] === "WHITE NON HISPANIC"){return bubblePaddedWidth*0.25}
                    //if (d["Ethnicity"] === "HISPANIC"){return bubblePaddedWidth*0.5}
                    // if (d["Ethnicity"] === "BLACK NON HISPANIC"){return bubblePaddedWidth*0.75}
                    // if (d["Ethnicity"] === "ASIAN AND PACIFIC ISLANDER"){return bubblePaddedWidth}
                    else {return 0}}).strength( 0.8 ) )
                  .force("collision", d3.forceCollide()
                                                       .radius(28)
                                                       .iterations(2) )
                  .on("tick", render);


      // Update the chart for a new tick of the simulation
      function render() {

        // Edges
        // let lines = bubbleLayer.selectAll("line.link").data(nameBubbleData)
        //      .join(
        //        enter => enter.append("line")
        //                      .attr("class","link")
        //                      .attr("stroke","#333")
        //      )
        //      .attr("x1", d => d.x).attr("x2", 1)
        //      .attr("y1", d => d.y).attr("y2", 1);


        let labels = bubbleLegend.selectAll("text.label").data(nameBubbleData)
             .join(
               enter => enter.append("text")
                             .attr("class","label")
                             //.attr("stroke","#333")
                             .text(function(d){return d["Child's First name"]})
                             .attr("text-anchor", "middle")
                             .attr("alignment-baseline", "middle")
          
             )
             .attr("x", d => d.x).attr("y", d => d.y)

        // Nodes
        let circles = bubbleLayer.selectAll("circle.node").data(nameBubbleData)
               .join(
                  enter => enter.append("circle")
                                .attr("class","node")
                                .attr("stroke", d=>genderColorScale(d.Gender))
                                .attr("stroke-width", 5)
                                .attr("stroke-alignment","outer")
                                .attr("r", 26)
                                .attr("cx", 0)
                                .attr("cy", 0)
                                .attr("fill", d => colorScale(d.Ethnicity))
                                // .call( d3.drag().on("start",dragstart)
                                //                 .on("drag",dragging)
                                //                 .on("end",dragend) )
                )
               .attr("transform", d => `translate(${d.x},${d.y})`);
      }//end of render




      ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
      //Connected scatter plot, i.e. line chart/////
      // set the dimensions and margins of the graph
      const lineGraphLayer = d3.select("#lineGraph").append("g");
      const lineLegend = d3.select("#lineGraph").append("g");
      const lineWidth = d3.select("#lineGraph").attr("width");
      const lineHeight = d3.select("#lineGraph").attr("height");
      const linePadding = 50
      const linePaddedHeight = lineHeight - 2*linePadding
      const linePaddedWidth = lineWidth - 2*linePadding

      
      var x = d3.scaleTime()
        .domain(d3.extent(nameBubbleData, d=>d.Count))
        .range([ 0, lineWidth ]);
      lineGraphLayer.append("g")
        .attr("transform", "translate(0," + lineHeight + ")")
        .call(d3.axisBottom(x));
      // Add Y axis
      var y = d3.scaleLinear()
        .domain( [8000, 9200])
        .range([ lineHeight, 0 ]);
      lineGraphLayer.append("g")
        .call(d3.axisLeft(y));
      // Add the line
      lineGraphLayer.append("path")
        .datum(nameBubbleData)
        .attr("fill", "none")
        .attr("stroke", "#69b3a2")
        .attr("stroke-width", 1.5)
        .attr("d", d3.line()
          .x(function(d) { return x(d.date) })
          .y(function(d) { return y(d.value) })
          )
      // Add the points
      lineGraphLayer.append("g")
        .selectAll("dot")
        .data(nameBubbleData)
        .enter()
        .append("circle")
          .attr("cx", function(d) { return x(d.date) } )
          .attr("cy", function(d) { return y(d.value) } )
          .attr("r", 5)
          .attr("fill", "#69b3a2")
      
         



    }//////DO not delete!!!!!!!!, from await function
    requestData()
  </script>
</body>
</html>
